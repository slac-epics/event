#
# evrDevTrig.db
#
# Need one instance for each trigger output you're controlling
# For PMC 230 EVR's w/ no transition board, there are just the
# three on the front panel.
# For VME 230 EVR's w/ no transition board, there are eight
# For EVR's w/ a transition board, up to 16 more triggers are available
#
# Required macros:
#	EVR  - EVR PV prefix
#	TRIG - Trigger PV prefix
#	TYPE - DG or OT (Extended Delay Pulse Generator or OTP Pulse Generator)
#	N	 - Trigger number (0, 1, 2, ...)
#	TCTL - Trigger control (enable) field, one of DG0E, DG1E, DG2E, OTP0, ..., OTPD

# Optional macros:
#	DESC - Trigger description
#	DES	 - Trigger TDES, desired delay value, default 0
#	WID	 - Initial Trigger width, default 100ns
#	POL	 - Initial Trigger polarity, default 0 (NORMAL)
#	CTL	 - Initial Trigger enable, default 1 (Enabled)
#	ACTV - Invariant Trigger Activate, default 1
#	SYS  - EVG System specifier, default SYS0
#	DRVH - High limit of desired delay, default  2.8E06
#	DRVL - Low  limit of desired delay, default -2.8E06
#

# Trigger type
record(bo, "$(TRIG):TYPE" )
{
  field(DOL,  "$(TYPE)")
  field(OMSL, "closed_loop")
  field(ZNAM, "DG")
  field(ONAM, "OT")
  field(PINI, "YES")
}

# Tick count for the trigger
# Corresponds to the number of 8.4ns EVR time slots
# between the fiducial event code 1 and the current
# trigger event code.
# Value set by record $(TRIG):ASUB_LKUOFFSET
record(ai, "$(TRIG):TOFFSET")
{
  field(DESC, "Tick cnt for cur ec")
  field(PINI, "NO")
  field(EGU,  "ticks")
  field(FLNK, "$(TRIG):TOFFSET_NS")
}

record(calc, "$(TRIG):TOFFSET_NS")
{
  field(DESC, "Offset in ns for ec")
  field(EGU,  "ns")
  field(CALC, "A*B")
  field(INPA, "$(TRIG):TOFFSET.VAL MS")
  field(INPB, "8.403361345")
  field(FLNK, "$(TRIG):TDES")
}

# This PV looks up the tick offset of
# the current event code for this trigger
# The event code is read by $(TRIG):LSUB_EVSEL and
# this record processes each time LSUB_EVSEL updates
record(aSub, "$(TRIG):ASUB_LKUOFFSET")
{
  field(DESC, "Offset lookup")
  field(SCAN, "Passive")
  field(PINI, "YES")
  field(INAM, "aSubEvOffsetInit")
  field(SNAM, "aSubEvOffset")
  field(INPA, "$(TRIG):LSUB_EVSEL.VAL NPP MS")
  field(INPB, "$(ACTV=1)")
  field(INPC, "EVNT:$(SYS=SYS0):1:DELAY CPP MS")
  field(INPD, "0")
  field(FTA, "LONG")
  field(FTB, "LONG")
  field(FTC, "LONG")
  field(FTD, "LONG")
  field(NOC, "256")
  field(OUTA, "$(TRIG):TOFFSET.VAL PP MS")
  field(FTVA, "LONG")
  field(FLNK, "$(TRIG):TDES")
}

# PV to read currently assigned event code
# Processes whenever any of the 14 event controls
# posts a CA monitor event, which will happen
# if their event code is changed.
# Uses the LSUB_TRGSEL value to specify which control
# record's event code number to read
record(longSub, "$(TRIG):LSUB_EVSEL")
{
  field(DESC, "Event Code Read")
  field(SCAN, "Passive")
  field(INAM, "lsubEvSelInit")
  field(SNAM, "lsubEvSel")
  field(INPA, "$(EVR):EVENT1CTRL.ENM CPP NMS")
  field(INPB, "$(EVR):EVENT2CTRL.ENM CPP NMS")
  field(INPC, "$(EVR):EVENT3CTRL.ENM CPP NMS")
  field(INPD, "$(EVR):EVENT4CTRL.ENM CPP NMS")
  field(INPE, "$(EVR):EVENT5CTRL.ENM CPP NMS")
  field(INPF, "$(EVR):EVENT6CTRL.ENM CPP NMS")
  field(INPG, "$(EVR):EVENT7CTRL.ENM CPP NMS")
  field(INPH, "$(EVR):EVENT8CTRL.ENM CPP NMS")
  field(INPI, "$(EVR):EVENT9CTRL.ENM CPP NMS")
  field(INPJ, "$(EVR):EVENT10CTRL.ENM CPP NMS")
  field(INPK, "$(EVR):EVENT11CTRL.ENM CPP NMS")
  field(INPL, "$(EVR):EVENT12CTRL.ENM CPP NMS")
  field(INPM, "$(EVR):EVENT13CTRL.ENM CPP NMS")
  field(INPN, "$(EVR):EVENT14CTRL.ENM CPP NMS")
  field(INPV, "$(TRIG):LSUB_TRGSEL.VAL MS")
  field(FLNK, "$(TRIG):ASUB_LKUOFFSET")
}

# This PV examines each of the 14 control records to find
# the first one which is enabled for this trigger's output
# It's value is 0 if EVENT1CTRL is enabled, 1 for EVENT2CTRL, ...
record(longSub, "$(TRIG):LSUB_TRGSEL")
{
  field(DESC, "Delay Selector")
  field(SCAN, "Passive")
  field(PINI, "YES")
  field(INAM, "lsubTrigSelInit")
  field(SNAM, "lsubTrigSel")
  field(INPA, "$(EVR):EVENT1CTRL.OUT$(N) CPP NMS")
  field(INPB, "$(EVR):EVENT2CTRL.OUT$(N) CPP NMS")
  field(INPC, "$(EVR):EVENT3CTRL.OUT$(N) CPP NMS")
  field(INPD, "$(EVR):EVENT4CTRL.OUT$(N) CPP NMS")
  field(INPE, "$(EVR):EVENT5CTRL.OUT$(N) CPP NMS")
  field(INPF, "$(EVR):EVENT6CTRL.OUT$(N) CPP NMS")
  field(INPG, "$(EVR):EVENT7CTRL.OUT$(N) CPP NMS")
  field(INPH, "$(EVR):EVENT8CTRL.OUT$(N) CPP NMS")
  field(INPI, "$(EVR):EVENT9CTRL.OUT$(N) CPP NMS")
  field(INPJ, "$(EVR):EVENT10CTRL.OUT$(N) CPP NMS")
  field(INPK, "$(EVR):EVENT11CTRL.OUT$(N) CPP NMS")
  field(INPL, "$(EVR):EVENT12CTRL.OUT$(N) CPP NMS")
  field(INPM, "$(EVR):EVENT13CTRL.OUT$(N) CPP NMS")
  field(INPN, "$(EVR):EVENT14CTRL.OUT$(N) CPP NMS")
  field(FLNK, "$(TRIG):LSUB_EVSEL")
}

record(seq, "$(TRIG):PROP_SEQ")
{
  field(PINI, "YES")
  field(DLY1, "15.")
  field(DOL1, "1.")
  field(LNK1, "$(TRIG):FW_SEQ.DLY1")
}

record(fanout, "$(TRIG):FW_FOUT")
{
  field(FLNK, "$(TRIG):FW_SEQ")
  field(LNK1, "$(TRIG):TDLY")
}

# This PV computes and sets the Trigger Delay
# It's VAL field follows TDLYCALC, the required
# additional trigger delay in ns
# It scales the output by the 119MHz clock speed
# to compute the tick count in it's RVAL field,
# which is written to the appropriate EVR control delay
record(ao, "$(TRIG):TDLY")
{
  field(DESC, "Trigger EVR Delay")
  field(DTYP, "Raw Soft Channel")
  field(OMSL, "closed_loop")
  field(DOL, "$(TRIG):TDLYCALC.VAL NPP MS")
  field(LINR, "SLOPE")
  field(ESLO, "8.403361345")
  field(OUT, "$(EVR):CTRL.$(TYPE)$(N)D PP NMS")
  field(EGU, "ns")
  field(HOPR, "1000000000")
  field(DRVH, "1000000000")
}

record(seq, "$(TRIG):FW_SEQ")
{
  field(DLY1, "15")
  field(DOL1, "0.")
  field(LNK1, "$(TRIG):BW_SW.VAL PP")
}

# This PV calculates the additional delay in ns
# after the event code before the trigger is generated
record(calc, "$(TRIG):TDLYCALC")
{
  field(DESC, "Trigger Delay")
  field(CALC, "A+B-(C*D)")
  field(INPA, "$(TRIG):TDES.VAL")
  field(INPB, "$(EVR):TREF CPP")
  field(INPC, "$(TRIG):TOFFSET.VAL")
  field(INPD, "8.403361345")
  field(EGU,  "ns")
  field(HOPR, "1000000000")
  field(PREC, "1")
  field(SDIS, "$(TRIG):FW_SW.VAL")
  field(FLNK, "$(TRIG):FW_FOUT")
}

record(ao, "$(TRIG):BW_DIS")
{
  field(OUT, "$(TRIG):BW_SW.VAL PP")
  field(DOL, "1")
  field(OMSL, "closed_loop")
  field(SDIS, "$(TRIG):FW_SW.VAL")
  field(FLNK, "$(TRIG):TDLYCALC")
}

# Desired trigger delay as an offset relative
# to $(EVR):TREF, the trigger reference time
record(ao, "$(TRIG):TDES")
{
  field(DESC, "Desired Trig Delay")
  field(DTYP, "Raw Soft Channel")
  field(OMSL, "supervisory")
  field(LINR, "SLOPE")
  field(EGU, "ns")
  field(PREC, "1")
  field(HOPR, "$(DRVH=2.8E06)")
  field(LOPR, "$(DRVL=-2.8E06)")
  field(DRVH, "$(DRVH=2.8E06)")
  field(DRVL, "$(DRVL=-2.8E06)")
  field(ESLO, "8.403361345")
  field(FLNK, "$(TRIG):BW_DIS")
  field(VAL, "$(DES=0)")
  field(MDEL, "-1")
  field(PINI, "YES")
  field(LSV,  "MINOR")
  field(FLNK, "$(TRIG):BW_DIS")
  info(autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL")
}

# Update TDES.LOW based on 0 tick delay
# Setting at 0.01 lower than calculated to avoid
# flagging 0 delays on EC 140 due to rounding errors
record(calcout, "$(TRIG):TDES_CALC_LOW")
{
  field(DESC, "TDES low limit calc" )
  field(CALC, "A*B-C-0.01")
  field(INPA, "$(TRIG):TOFFSET.VAL CPP MS")
  field(INPB, "8.403361345")
  field(INPC, "$(EVR):TREF CPP MS")
  field(EGU,  "ns")
  field(PREC, "2")
  field(OUT,  "$(TRIG):TDES.LOW PP NMS")
}

record(ai, "$(TRIG):FW_SW")
{
}

record(ai, "$(TRIG):BW_SW")
{
}

# Grab the delay tick count for easy edm viewing w/ EGU of ticks
record(longin, "$(TRIG):BW_TICKCALC")
{
  field(DESC, "Tick count from delay gen" )
  field(INP,  "$(EVR):CTRL.$(TYPE)$(N)D CPP MS")
  field(EGU,  "ticks")
  field(FLNK, "$(TRIG):BW_TDLYCALC")
}

# Compute time delay in ns after the event code
record(calc, "$(TRIG):BW_TDLYCALC")
{
  field(DESC, "Backward delay after EC" )
  field(SCAN, "Passive")
  field(CALC, "A*B")
  field(INPA, "$(TRIG):BW_TICKCALC NPP MS")
  field(INPB, "8.403361345")
  field(EGU,  "ns")
  field(PREC, "2")
  field(FLNK, "$(TRIG):BW_TDESCALC")
}

# Compute desired delay relative to TREF (ns)
record(calc, "$(TRIG):BW_TDESCALC")
{
  field(DESC, "Backward TDES calc" )
  field(SCAN, "Passive")
  field(CALC, "(A+B)*C-D")
  field(INPA, "$(TRIG):TOFFSET.VAL CPP MS")
  field(INPB, "$(TRIG):BW_TICKCALC NPP MS")
  field(INPC, "8.403361345")
  field(INPD, "$(EVR):TREF CPP MS")
  field(EGU,  "ns")
  field(PREC, "2")
  field(FLNK, "$(TRIG):FW_DIS")
}

# Updates TDES from BW_TDESCALC when processed
record(ao, "$(TRIG):BW_TDES")
{
  field(OUT, "$(TRIG):TDES.VAL PP")
  field(DOL, "$(TRIG):BW_TDESCALC.VAL")
  field(OMSL, "closed_loop")
}

# Enable forward calc path after short delay
record(seq, "$(TRIG):BW_SEQ")
{
  field(DLY1, "1.")
  field(DOL1, "0")
  field(LNK1, "$(TRIG):FW_SW.VAL PP")
}

# Disable forward calc path
record(ao, "$(TRIG):FW_DIS")
{
  field(FLNK, "$(TRIG):BW_FOUT")
  field(OUT, "$(TRIG):FW_SW.VAL PP")
  field(DOL, "1")
  field(OMSL, "closed_loop")
  field(SDIS, "$(TRIG):BW_SW.VAL")
}

# Backward fanout
# Processes BW_TDES to update TDES,
# then enables forward calc path
record(fanout, "$(TRIG):BW_FOUT")
{
  field(LNK1, "$(TRIG):BW_TDES")
  field(FLNK, "$(TRIG):BW_SEQ")
}

record(seq, "$(TRIG):PROP_SEQ2")
{
  field(PINI, "YES")
  field(DLY1, "15")
  field(DOL1, "1")
  field(LNK1, "$(TRIG):FW_SEQ2.DLY1")
}

record(longout, "$(TRIG):EVENTCTRL")
{
  field(DESC, "$(DESC=Trigger Description)")
  field(PINI, "YES")
}

record(ao, "$(TRIG):TCON")
{
  field(DESC, "Trigger Delay")
  field(EGU, "ns")
  field(HOPR, "$(DRVH=2.8E06)")
  field(LOPR, "$(DRVL=-2.8E06)")
  field(DRVH, "$(DRVH=2.8E06)")
  field(DRVL, "$(DRVL=-2.8E06)")
  field(PINI, "YES")
  field(MDEL, "-1")
  info(autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL")
}

record(fanout, "$(TRIG):TINI")
{
  field(DESC, "Trigger Init")
  field(PINI, "YES")
  field(LNK1, "$(TRIG):TDES PP")
  field(LNK2, "$(TRIG):TWID PP")
  field(LNK3, "$(TRIG):TPOL PP")
  field(LNK4, "$(TRIG):TCTL PP")
}

record(seq, "$(TRIG):TPOL_ITNSEQ")
{
  field(DLY1, "0")
  field(DOL1, "0")
  field(LNK1, "$(TRIG):TPOL_ITN.DISV")
  field(DLY2, ".5")
  field(DOL2, "1")
  field(LNK2, "$(TRIG):TPOL_ITN.DISV")
}

record(bo, "$(TRIG):TPOL_ITN")
{
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(OMSL, "closed_loop")
  field(DOL, "$(EVR):CTRL.$(TYPE)$(N)P CPP NMS")
  field(OUT, "$(TRIG):TPOL.VAL PP")
  field(ZNAM, "Normal")
  field(ONAM, "Inverted")
  field(FLNK, "$(TRIG):TPOL_ITNSEQ")
}

record(ao, "$(TRIG):TWID")
{
  field(DESC, "Trigger Width")
  field(DTYP, "Raw Soft Channel")
  field(OMSL, "supervisory")
  field(LINR, "SLOPE")
  field(EGU, "ns")
  field(HOPR, "1000000000")
  field(DRVH, "1000000000")
  field(ESLO, "8.403361345")
  field(VAL, "$(WID=100)")
  field(MDEL, "-1")
  field(FLNK, "$(TRIG):BW_DIS2")
  field(PINI, "YES")
  info(autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL")
}

record(bo, "$(TRIG):TPOL")
{
  field(DESC, "Trigger Polarity")
  field(DTYP, "Soft Channel")
  field(OUT, "$(EVR):CTRL.$(TYPE)$(N)P PP")
  field(ZNAM, "Normal")
  field(ONAM, "Inverted")
  field(OMSL, "supervisory")
  field(VAL, "$(POL=0)")
  field(PINI, "YES")
  info(autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV")
}

record(bo, "$(TRIG):TCTL")
{
  field(DESC, "Trigger Control")
  field(DTYP, "Soft Channel")
  field(OUT, "$(EVR):CTRL.$(TCTL) PP")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
  field(OMSL, "supervisory")
  field(VAL, "$(CTL=1)")
  field(PINI, "YES")
  info(autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV")
}

record(seq, "$(TRIG):TCTL_ITNSEQ")
{
  field(DLY1, "0")
  field(DOL1, "0")
  field(LNK1, "$(TRIG):TCTL_ITN.DISV")
  field(DLY2, ".5")
  field(DOL2, "1")
  field(LNK2, "$(TRIG):TCTL_ITN.DISV")
}

record(bo, "$(TRIG):TCTL_ITN")
{
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(OMSL, "closed_loop")
  field(DOL, "$(EVR):CTRL.$(TCTL) CPP NMS")
  field(OUT, "$(TRIG):TCTL.VAL PP")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
  field(FLNK, "$(TRIG):TCTL_ITNSEQ")
}

record(ao, "$(TRIG):BW_DIS2")
{
  field(FLNK, "$(TRIG):FW_FOUT2")
  field(OUT, "$(TRIG):BW_SW2.VAL PP")
  field(DOL, "1")
  field(OMSL, "closed_loop")
  field(SDIS, "$(TRIG):FW_SW2.VAL")
}

record(ai, "$(TRIG):FW_SW2")
{
}

record(seq, "$(TRIG):BW_SEQ2")
{
  field(DLY1, "1.")
  field(DOL1, "0")
  field(LNK1, "$(TRIG):FW_SW2.VAL PP")
}

record(fanout, "$(TRIG):FW_FOUT2")
{
  field(SDIS, "$(TRIG):FW_SW2.VAL")
  field(FLNK, "$(TRIG):FW_SEQ2")
  field(LNK1, "$(TRIG):TWID2")
}

record(seq, "$(TRIG):FW_SEQ2")
{
  field(DLY1, "15")
  field(DOL1, "0")
  field(LNK1, "$(TRIG):BW_SW2.VAL PP")
}

record(fanout, "$(TRIG):BW_FOUT2")
{
  field(FLNK, "$(TRIG):BW_SEQ2")
  field(LNK1, "$(TRIG):BW_TWID")
}

record(ai, "$(TRIG):BW_SW2")
{
}

record(ao, "$(TRIG):BW_TWID")
{
  field(SDIS, "$(TRIG):BW_SW2.VAL")
  field(OUT, "$(TRIG):TWID.VAL PP")
  field(DOL, "$(TRIG):BW_TWIDCALC.VAL")
  field(OMSL, "closed_loop")
}

record(ao, "$(TRIG):FW_DIS2")
{
  field(FLNK, "$(TRIG):BW_FOUT2")
  field(OUT, "$(TRIG):FW_SW2.VAL PP")
  field(DOL, "1")
  field(OMSL, "closed_loop")
  field(SDIS, "$(TRIG):BW_SW2.VAL")
}

record(ao, "$(TRIG):TWID2")
{
  field(DESC, "Trigger Width")
  field(DTYP, "Raw Soft Channel")
  field(OUT, "$(EVR):CTRL.$(TYPE)$(N)W PP")
  field(OMSL, "closed_loop")
  field(LINR, "SLOPE")
  field(EGU, "ns")
  field(PREC, "1")
  field(HOPR, "1000000000")
  field(DRVH, "1000000000")
  field(ESLO, "8.403361345")
  field(VAL, "$(WID=100)")
  field(MDEL, "-1")
  field(SDIS, "$(TRIG):FW_SW2.VAL")
  field(DOL, "$(TRIG):TWID.VAL")
}

# Grab the width tick count for easy edm viewing w/ EGU of ticks
record(longin, "$(TRIG):BW_TWID_TICKS")
{
  field(DESC, "Width from delay gen" )
  field(INP,  "$(EVR):CTRL.$(TYPE)$(N)W CPP MS")
  field(EGU,  "ticks")
  field(FLNK, "$(TRIG):BW_TWIDCALC")
}

record(calc, "$(TRIG):BW_TWIDCALC")
{
  field(INPA, "$(TRIG):BW_TWID_TICKS NPP MS")
  field(INPB, "8.403361345")
  field(CALC, "A*B")
  field(EGU,  "ns")
  field(PREC, "1")
  field(FLNK, "$(TRIG):FW_DIS2")
}

# Records for fetching the trigger's event code, count, rate, and event name.
record( longSub, "$(TRIG):CNT" )
{
	field( DESC, "Trigger Count" )
	field( SNAM, "evrTimeEvent" )
	field( BRSV, "INVALID" )
	field( INPA, "$(TRIG):LSUB_EVSEL NPP" )
	field( SCAN, ".1 second" )
}

record( sub, "$(TRIG):RATE" )
{
	field( DESC, "Trigger Rate" )
	field( SNAM, "evrTimeRate" )
	field( BRSV, "INVALID" )
	field( SCAN, "Event" )
	field( EVNT, "121" )
	field( PRIO, "MEDIUM" )
	field( INPE, "$(TRIG):LSUB_EVSEL NPP" )
	field( EGU,  "Hz" )
	field( PREC, "1" )
	field( LOW,  "0" )
	field( LSV,  "MINOR" )
}

# This record returns a copy of the event code name
# for the event code specified by it's EVNT field.
# Update that field dynamically to fetch the name
# for a different event code.
record( stringin, "$(TRIG):EC_NAME" )
{
	field( DESC,  "Get event code name" )
	field( DTYP,  "MRF Event Receiver" )
	field( INP,   "#C$(CARD) S0 @" )
	field( EVNT,  "0" )
}

record( longout, "$(TRIG):EC" )
{
	field( DESC, "Trigger's Event code" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(TRIG):LSUB_EVSEL CPP MS" )
	field( OUT,  "$(TRIG):EC_NAME.EVNT" )
	field( FLNK, "$(TRIG):EC_NAME.EVNT PP MS" )
}

# PV to fetch the current number of enabled outputs for
# this trigger's control record
# Processes whenever any of the 14 CTRL_N_OUTPUTS_ON PV's updates
# Uses the LSUB_TRGSEL value to specify which control
# record's count to read
record( longSub, "$(TRIG):CTRL_N_OUTPUTS_ON" )
{
	field( DESC, "# outputs for this ctrl" )
	field( SCAN, "Passive" )
	field( INAM, "lsubEvSelInit" )
	field( SNAM, "lsubEvSel" )
	field( INPA, "$(EVR):EVENT1CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPB, "$(EVR):EVENT2CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPC, "$(EVR):EVENT3CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPD, "$(EVR):EVENT4CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPE, "$(EVR):EVENT5CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPF, "$(EVR):EVENT6CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPG, "$(EVR):EVENT7CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPH, "$(EVR):EVENT8CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPI, "$(EVR):EVENT9CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPJ, "$(EVR):EVENT10CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPK, "$(EVR):EVENT11CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPL, "$(EVR):EVENT12CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPM, "$(EVR):EVENT13CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPN, "$(EVR):EVENT14CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPV, "$(TRIG):LSUB_TRGSEL.VAL NMS" )
	field( FLNK, "$(TRIG):CTRL_IS_SHARED_CALC" )
}

# PV to determine if this trigger shares it's control record
# with other outputs
record( calc, "$(TRIG):CTRL_IS_SHARED_CALC" )
{
	field( INPA, "$(TRIG):CTRL_N_OUTPUTS_ON NPP NMS" )
	field( INPB, "$(TRIG):TCTL CPP MS" )
	field( CALC, "B?(A>1):(A>0)" )
	field( PINI, "YES" )
	field( FLNK, "$(TRIG):CTRL_IS_SHARED" )
}

record( bo, "$(TRIG):CTRL_IS_SHARED" )
{
	field( DOL,  "$(TRIG):CTRL_IS_SHARED_CALC" )
	field( OMSL, "closed_loop" )
	field( ZNAM, "Private" )
	field( ONAM, "Shared" )
}
