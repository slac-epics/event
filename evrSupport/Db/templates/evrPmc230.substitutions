#
# Basic PMC EVR 230 Event Substitutions file
# Set event specific variations here.
# Set EVR and IOC in dbLoadRecords()
# Example:
# dbLoadRecords( "db/evrPmc230.db", "IOC=AMO:R06:IOC:19,EVR=AMO:R06:EVR:19" )
#

file evrPmc230.template
{
#       Device  Card
#           FP*L        Trigger name
#           DG*E        {Enabled|Disabled}
#           DG*P        {Normal|Inverted}
#           DG*W        {Width}
#           DG*D        {Delay}
#           DG*C        {ScaleFactor}
    pattern
    {   DEV,    CARD,
        FP0L,   DG0E,       DG0P,   DG0W,       DG0D,   DG0C,
        FP1L,   DG1E,       DG1P,   DG1W,       DG1D,   DG1C,
        FP2L,   DG2E,       DG2P,   DG2W,       DG2D,   DG2C,
        FP3L,   DG3E,       DG3P,   DG3W,       DG3D,   DG3C,
    }

    {   $(EVR), 0,
        "Spare",    Enabled,    Normal,     1000,   500,    119,
        "Spare",    Enabled,    Normal,     1000,   750,    119,
        "Spare",    Disabled,   Normal,     5000,   500,    119,
        "Spare",    Disabled,   Normal,     5000,   500,    119,
    } 
}


#   DEV     Name of EVR
#   CARD    EVR card number starting at 0 (matches card number in ErConfigure).
#   NAME    EVENT1 to EVENT14 - instantiate all 14 records even if you only use a few events.
#   ID  Event code number.
#   P0 to P2 - trigger state for channels 0 to 2
#       (0 = disabled for the event code, 1 = enabled for the event code)
#       Channels 0 to 2  are used for the front panel triggers.
# 
#   IRQ Controls whether an IRQ happens when this event code occurs.
#       (0 = no IRQ, 1 = IRQ)
#       Must be set to 1 if you want event record processing using the event code.
#       Must be set to 1 if you have records with TSE fields set to the event code.
file evrPmcEvent.template
{
#     Device    Card  <----------------------------  Event -------------------------->       
    pattern
    { DEV,      CARD,   NAME,    ID,  P0,P1,P2,IRQ, LNAME           }
    { $(EVR),   0,      EVENT1, 140,  1, 1, 1, 1, "Beam Full"       }
    { $(EVR),   0,      EVENT2, 141,  0, 0, 0, 0, "Beam & 60Hz"     }
    { $(EVR),   0,      EVENT3, 142,  0, 0, 0, 0, "Beam & 30Hz"     }
    { $(EVR),   0,      EVENT4, 143,  0, 0, 0, 0, "Beam & 10Hz"     }
    { $(EVR),   0,      EVENT5, 144,  0, 0, 0, 0, "Beam & 5Hz"      }
    { $(EVR),   0,      EVENT6, 145,  0, 0, 0, 0, "Beam & 1Hz"      }
    { $(EVR),   0,      EVENT7, 146,  0, 0, 0, 0, "Beam & 0.5Hz"    }
    { $(EVR),   0,      EVENT8,  40,  0, 0, 0, 0, "120Hz"           }
    { $(EVR),   0,      EVENT9,  41,  0, 0, 0, 0, "60Hz"            }
    { $(EVR),   0,      EVENT10, 42,  0, 0, 0, 0, "30Hz"            }
    { $(EVR),   0,      EVENT11, 43,  0, 0, 0, 0, "10Hz"            }
    { $(EVR),   0,      EVENT12, 44,  0, 0, 0, 0, "5Hz"             }
    { $(EVR),   0,      EVENT13, 45,  0, 0, 0, 0, "1Hz"             }
    { $(EVR),   0,      EVENT14, 46,  0, 0, 0, 0, "0.5Hz"           }
}


# Use evrPatternAll to get the PATTERN record
# PATTERN.L is the fiducial Beam ID
#
# Macros: evrPatternAll.db - instantiates 120hz pattern records.
#         Associated display is evrPatternDiags.edl.
#       DEVICE  Name of the IOC, IOC:<loca>:<unit>
#
#       LINK4   Set to "" if the IOC is not slc-aware.
#               Otherwise, set to "IOC:<loca>:<unit>:FANOUTSLC".
#
#       LINK5,  Set to any record you want processed at 120hz after the timing
#       LINK6   pattern is received.  If not applicable, set to "".
#
#       TREF    Reference delay in nsec from the fiducial for this IOC.  Normally
#               restored on reboot.  Nominal value is 1.03E6 nsec.  TREF is used
#               with the TDES value for each device to calculate the actual delay
#               updated in the EVR hardware:
#               EVR delay = TREF + TDES - event code delay from the fiducial
#
#       TS1ST   For 120hz operation, 2 of the 6 time slots (1,2,3,4,5,6,
#       and     360hz apart) are used to update the pattern and timestamp for
#       TS2ND   this IOC (pattern is used for beam sync acq).  The other 4 time
#               slots are used for other projects.  Check with operations to find
#               the time slots used for your project/run and fill them in.  For
#               instance, for BC1 LCLS 2007 operation, time slots 1 and 4 were
#               used so TS1ST was set to 1 and TS2ND was set to 4.  For IOCs that
#               cannot acquire and process data at 120hz (data ready in 8.3 msec),
#               set TS1ST to 0 to ignore the 1st timeslot and the pattern and
#               timestamp will only update on time slot 4 at 60hz.
#
#==============================================================================
#
file evrPatternAll.db
{
    {
        DEVICE=$(EVR),
        LINK4="",
        LINK5="",
        LINK6="",
        TREF=1.03E06,
        TS1ST=1,
        TS2ND=4
    }
}


#file lclsEventCodes.db
#{
#   { DEV="$(EVR)", CARD="0" }
#}

